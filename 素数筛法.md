
## 判断一个数是否是素数，复杂度sqrt(n)

```
public class Demo{

	//判断一个数是否是素数
	/** 为什么只需要判断[2,sqrt(n)]？
	 ** 反证法，假设[2,sqrt(n)]不能整除n，但存在一个数a属于(sqrt(n),n-1]能够整除n，即n = ak。
	 ** 因为n = sqrt(n)*sqrt(n)，因为a >= sqrt(n)，所以k<=sqrt(n)。已知[2,sqrt(n)]不能整除n，矛盾。
	 **/
	public boolean isPrime(int n){
		if(n <= 1){
			return false;
		}
		for(int i = 2; i*i <= n; i++ ){
			if(n%i == 0){
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args){
		Demo d = new Demo();
		for(int i = 0; i < 50; i++){
			System.out.println(i + " " + d.isPrime(i));
		}
	}
}
```

## 筛法

算法一：令A为素数，则A*N（N>1;N为自然数）都不是素数。
缺点是有些数字会被多多次删除，比如6会被2和3删除

<pre>
public class Demo{

	//找出1~N之间所有的素数
	public boolean[] getPrime(int n){
		boolean[] primes = new boolean[n+1];
		<font color='red'>//默认都是素数，然后一个个筛掉</font>
		for(int i = 0; i <= n; i++){
			primes[i] = true;
		}
		//0和1不是素数
		primes[0] = false;
		primes[1] = false;
		for(int i = 2;i <= n; i++){
			if(primes[i]){
				//素数的倍数必然不是素数，j是2倍，3倍...
				for(int j = 2; j <= n/i; j++){
					primes[i*j] = false;
				}
			}
		}
		return primes;
	}

	public static void main(String[] args){
		Demo d = new Demo();
		int n = 10000;
		boolean[] primes = d.getPrime(n);
		int count = 0;
		for(int i = 0; i <=n; i++){
			if(primes[i]){
				count ++;
				//System.out.print(i + " ");
			}
		}
		System.out.println(count);
	}
}
</pre>